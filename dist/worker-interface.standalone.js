// Uses Node, AMD or browser globals to create a module.
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.WorkerInterface = factory();
  }
}(this, function() {
  // here should be injected worker-interface.js content
  /**
   * Created by Oleg Galaburda on 23.02.16.
   */
  
  var Scripts = {
    DEPS_SRC:"var EventDispatcher = (function() {\r\n  /**\r\n   * Created by Oleg Galaburda on 09.02.16.\r\n   */\r\n  \r\n  var Event = (function() {\r\n  \r\n    function toJSON() {\r\n      return {type: this.type, data: this.data};\r\n    }\r\n  \r\n    function Event(type, data) {\r\n      var _defaultPrevented = false;\r\n  \r\n      function isDefaultPrevented() {\r\n        return _defaultPrevented;\r\n      }\r\n  \r\n      function preventDefault() {\r\n        _defaultPrevented = true;\r\n      }\r\n  \r\n      Object.defineProperties(this, {\r\n        type: {\r\n          value: type,\r\n          enumerable: true\r\n        },\r\n        data: {\r\n          value: data || null,\r\n          enumerable: true\r\n        }\r\n      });\r\n      this.preventDefault = preventDefault;\r\n      this.isDefaultPrevented = isDefaultPrevented;\r\n    }\r\n  \r\n    Event.prototype.toJSON = toJSON;\r\n  \r\n    return Event;\r\n  })();\r\n  \r\n  function isObject(value) {\r\n    return (typeof value === 'object') && (value !== null);\r\n  }\r\n  \r\n  var EventListeners = (function() {\r\n    function add(eventType, handler, priority) {\r\n      var handlers = createList(eventType, priority, this._listeners);\r\n      if (handlers.indexOf(handler) < 0) {\r\n        handlers.push(handler);\r\n      }\r\n    }\r\n  \r\n    function has(eventType) {\r\n      var result = false;\r\n      var priorities = getHashByKey(eventType, this._listeners);\r\n      if (priorities) {\r\n        for (var priority in priorities) {\r\n          if (priorities.hasOwnProperty(priority)) {\r\n            result = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  \r\n    function remove(eventType, handler) {\r\n      var priorities = getHashByKey(eventType, this._listeners);\r\n      if (priorities) {\r\n        var list = Object.getOwnPropertyNames(priorities);\r\n        var length = list.length;\r\n        for (var index = 0; index < length; index++) {\r\n          var priority = list[index];\r\n          var handlers = priorities[priority];\r\n          var handlerIndex = handlers.indexOf(handler);\r\n          if (handlerIndex >= 0) {\r\n            handlers.splice(handlerIndex, 1);\r\n            if (!handlers.length) {\r\n              delete priorities[priority];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    function removeAll(eventType) {\r\n      delete this._listeners[eventType];\r\n    }\r\n  \r\n    function call(event, target) {\r\n      var _stopped = false;\r\n      var _immediatelyStopped = false;\r\n  \r\n      function stopPropagation() {\r\n        _stopped = true;\r\n      }\r\n  \r\n      function stopImmediatePropagation() {\r\n        _immediatelyStopped = true;\r\n      }\r\n  \r\n      /*\r\n       * Three ways to implement this\r\n       * 1. As its now -- just assign and delete after event cycle finished\r\n       * 2. Use EventDispatcher.setupOptional()\r\n       * 3. In this method create function StoppableEvent that will extend from this event and add these functions,\r\n       *    then instantiate it for this one cycle.\r\n       */\r\n      event.stopPropagation = stopPropagation;\r\n      event.stopImmediatePropagation = stopImmediatePropagation;\r\n      /*\r\n       var rmStopPropagation = EventDispatcher.setupOptional(event, 'stopPropagation', stopPropagation);\r\n       var rmStopImmediatePropagation = EventDispatcher.setupOptional(event, 'stopImmediatePropagation', stopImmediatePropagation);\r\n       */\r\n      var priorities = getHashByKey(event.type, this._listeners);\r\n      if (priorities) {\r\n        var list = Object.getOwnPropertyNames(priorities).sort(function(a, b) {\r\n          return a - b;\r\n        });\r\n        var length = list.length;\r\n        for (var index = 0; index < length; index++) {\r\n          if (_stopped) break;\r\n          var handlers = priorities[list[index]];\r\n          var handlersLength = handlers.length;\r\n          for (var handlersIndex = 0; handlersIndex < handlersLength; handlersIndex++) {\r\n            if (_immediatelyStopped) break;\r\n            var handler = handlers[handlersIndex];\r\n            handler.call(target, event);\r\n          }\r\n        }\r\n      }\r\n      delete event.stopPropagation;\r\n      delete event.stopImmediatePropagation;\r\n      /*\r\n       rmStopPropagation();\r\n       rmStopImmediatePropagation();\r\n       */\r\n    }\r\n  \r\n    function createList(eventType, priority, target) {\r\n      var priorities = getHashByKey(eventType, target, Object);\r\n      return getHashByKey(parseInt(priority), priorities, Array);\r\n    }\r\n  \r\n    function getHashByKey(key, target, definition) {\r\n      var value = null;\r\n      if (target.hasOwnProperty(key)) {\r\n        value = target[key];\r\n      } else if (definition) {\r\n        value = target[key] = new definition();\r\n      }\r\n      return value;\r\n    }\r\n  \r\n    function EventListeners() {\r\n      /**\r\n       * key - event Type\r\n       * value - hash of priorities\r\n       *    key - priority\r\n       *    value - list of handlers\r\n       * @type {Object<string, Object.<string, Array<number, Function>>>}\r\n       * @private\r\n       */\r\n      this._listeners = {};\r\n    }\r\n  \r\n    EventListeners.prototype.add = add;\r\n    EventListeners.prototype.has = has;\r\n    EventListeners.prototype.remove = remove;\r\n    EventListeners.prototype.removeAll = removeAll;\r\n    EventListeners.prototype.call = call;\r\n  \r\n    return EventListeners;\r\n  })();\r\n  /**\r\n   *\r\n   * @param eventPreprocessor {?Function}\r\n   * @constructor\r\n   */\r\n  function EventDispatcher(eventPreprocessor) {\r\n    /**\r\n     * @type {EventListeners}\r\n     */\r\n    var _listeners = new EventListeners();\r\n  \r\n    function addEventListener(eventType, listener, priority) {\r\n      _listeners.add(eventType, listener, -priority || 0);\r\n    }\r\n  \r\n    function hasEventListener(eventType) {\r\n      return _listeners.has(eventType);\r\n    }\r\n  \r\n    function removeEventListener(eventType, listener) {\r\n      _listeners.remove(eventType, listener);\r\n    }\r\n  \r\n    function removeAllEventListeners(eventType) {\r\n      _listeners.removeAll(eventType);\r\n    }\r\n  \r\n    function dispatchEvent(event, data) {\r\n      var eventObject = EventDispatcher.getEvent(event, data);\r\n      if (eventPreprocessor) {\r\n        eventObject = eventPreprocessor.call(this, eventObject);\r\n      }\r\n      _listeners.call(eventObject);\r\n    }\r\n  \r\n    this.addEventListener = addEventListener;\r\n    this.hasEventListener = hasEventListener;\r\n    this.removeEventListener = removeEventListener;\r\n    this.removeAllEventListeners = removeAllEventListeners;\r\n    this.dispatchEvent = dispatchEvent;\r\n  }\r\n  \r\n  function getEvent(eventOrType, optionalData) {\r\n    var event = eventOrType;\r\n    if (!EventDispatcher.isObject(eventOrType)) {\r\n      event = new EventDispatcher.Event(String(eventOrType), optionalData);\r\n    }\r\n    return event;\r\n  }\r\n  \r\n  /*\r\n   function setupOptional(target, name, value) {\r\n   var cleaner = null;\r\n   if (name in target) {\r\n   cleaner = function() {\r\n   };\r\n   } else {\r\n   target[name] = value;\r\n   cleaner = function() {\r\n   delete target[name];\r\n   };\r\n   }\r\n   return cleaner;\r\n   }\r\n   EventDispatcher.setupOptional = setupOptional;\r\n   */\r\n  \r\n  EventDispatcher.isObject = isObject;\r\n  \r\n  EventDispatcher.getEvent = getEvent;\r\n  EventDispatcher.Event = Event;\r\n  \r\n  return EventDispatcher;\r\n})();\r\nvar MessagePortDispatcher = (function() {\r\n  /**\r\n   * Created by Oleg Galaburda on 09.02.16.\r\n   */\r\n  \r\n  var MessagePortEvent = (function() {\r\n  \r\n  \r\n    function MessagePortEvent(event, dispatcherId) {\r\n      this.event = event;\r\n      this.dispatcherId = dispatcherId;\r\n    }\r\n  \r\n    function toJSON() {\r\n      return {\r\n        event: MessagePortDispatcher.toJSON(this.event),\r\n        dispatcherId: this.dispatcherId\r\n      };\r\n    }\r\n  \r\n    MessagePortEvent.prototype.toJSON = toJSON;\r\n  \r\n    function fromJSON(object) {\r\n      var result = MessagePortDispatcher.fromJSON(object);\r\n      if (MessagePortEvent.isEvent(result)) {\r\n        result.event = MessagePortDispatcher.fromJSON(result.event);\r\n      } else {\r\n        result = null;\r\n      }\r\n      return result;\r\n    }\r\n  \r\n    MessagePortEvent.fromJSON = fromJSON;\r\n  \r\n    function isEvent(object) {\r\n      return EventDispatcher.isObject(object) && object.hasOwnProperty('dispatcherId') && object.hasOwnProperty('event');\r\n    }\r\n  \r\n    MessagePortEvent.isEvent = isEvent;\r\n  \r\n    return MessagePortEvent;\r\n  })();\r\n  \r\n  /**\r\n   *\r\n   * @param target {Window|Worker|MessagePort}\r\n   * @param customPostMessageHandler {?Function} Function that receive message object and pass it to MessagePort.postMessage()\r\n   * @param receiverEventPreprocessor {?Function} Function that pre-process all events received from MessagePort, before passing to listeners\r\n   * @param senderEventPreprocessor Function that pre-process all events sent to MessagePort\r\n   * @constructor\r\n   */\r\n  function MessagePortDispatcher(target, customPostMessageHandler, receiverEventPreprocessor, senderEventPreprocessor) {\r\n    target = target || self;\r\n    var _dispatcherId = 'MP/' + String(Math.ceil(Math.random() * 10000)) + '/' + String(Date.now());\r\n    var postMessageHandler = customPostMessageHandler || function(data, transferList) {\r\n        target.postMessage(data, this.targetOrigin, transferList);\r\n      };\r\n    /**\r\n     * @type {EventDispatcher}\r\n     */\r\n    var _sender = new EventDispatcher();\r\n    /**\r\n     * @type {EventDispatcher}\r\n     */\r\n    var _receiver = new EventDispatcher(receiverEventPreprocessor);\r\n  \r\n    function messageHandler(event) {\r\n      var message = MessagePortEvent.fromJSON(event.data);\r\n      if (message) {\r\n        if (message.dispatcherId === _dispatcherId) {\r\n          _sender.dispatchEvent(message.event);\r\n        } else {\r\n          _receiver.dispatchEvent(message.event);\r\n        }\r\n      }\r\n    }\r\n  \r\n    function dispatchEvent(event, data, transferList) {\r\n      event = EventDispatcher.getEvent(event, data);\r\n      if (senderEventPreprocessor) {\r\n        event = senderEventPreprocessor.call(this, event);\r\n      }\r\n      var eventJson = MessagePortDispatcher.toJSON(new MessagePortEvent(event, _dispatcherId));\r\n      postMessageHandler.call(this, eventJson, transferList);\r\n    }\r\n  \r\n    this.targetOrigin = '*';\r\n    this.addEventListener = _receiver.addEventListener;\r\n    this.hasEventListener = _receiver.hasEventListener;\r\n    this.removeEventListener = _receiver.removeEventListener;\r\n    this.removeAllEventListeners = _receiver.removeAllEventListeners;\r\n    this.dispatchEvent = dispatchEvent;\r\n  \r\n    Object.defineProperties(this, {\r\n      sender: {\r\n        value: _sender\r\n      },\r\n      receiver: {\r\n        value: _receiver\r\n      },\r\n      target: {\r\n        value: target\r\n      },\r\n      dispatcherId: {\r\n        value: _dispatcherId\r\n      }\r\n    });\r\n  \r\n    target.addEventListener('message', messageHandler);\r\n  }\r\n  \r\n  /**\r\n   * If toJSON method implemented on object, it will be called instead of converting to JSON string.\r\n   * This was made to utilize structured cloning algorithm for raw objects.\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n   * In this case developer is responsible for converting linked objects.\r\n   * @param object\r\n   * @returns {Object|String}\r\n   */\r\n  MessagePortDispatcher.toJSON = function(object) {\r\n    var objectJson;\r\n    if (typeof(object.toJSON) === 'function') {\r\n      objectJson = object.toJSON();\r\n    } else {\r\n      objectJson = JSON.stringify(object);\r\n    }\r\n    return objectJson;\r\n  };\r\n  /**\r\n   *\r\n   * @param data {Object|String}\r\n   * @returns {Object}\r\n   */\r\n  MessagePortDispatcher.fromJSON = function(data) {\r\n    var object; // keep it undefined in case of error\r\n    if (EventDispatcher.isObject(data)) {\r\n      object = data;\r\n    } else {\r\n      try {\r\n        object = JSON.parse(data);\r\n      } catch (error) {\r\n        // this isn't an event we are waiting for.\r\n      }\r\n    }\r\n    return object;\r\n  };\r\n  \r\n  var _self = null;\r\n  var _parent = null;\r\n  var _top = null;\r\n  /**\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @returns {MessagePortDispatcher}\r\n   */\r\n  MessagePortDispatcher.self = function(receiverEventPreprocessor, senderEventPreprocessor) {\r\n    if (!_self) {\r\n      _self = new MessagePortDispatcher(self, null, receiverEventPreprocessor, senderEventPreprocessor);\r\n    }\r\n    return _self;\r\n  };\r\n  /**\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @returns {MessagePortDispatcher}\r\n   */\r\n  MessagePortDispatcher.parent = function(receiverEventPreprocessor, senderEventPreprocessor) {\r\n    if (!_parent) {\r\n      _parent = new MessagePortDispatcher(parent, null, receiverEventPreprocessor, senderEventPreprocessor);\r\n    }\r\n    return _parent;\r\n  };\r\n  /**\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @returns {MessagePortDispatcher}\r\n   */\r\n  MessagePortDispatcher.top = function(receiverEventPreprocessor, senderEventPreprocessor) {\r\n    if (!_top) {\r\n      _top = new MessagePortDispatcher(top, null, receiverEventPreprocessor, senderEventPreprocessor);\r\n    }\r\n    return _top;\r\n  };\r\n  \r\n  return MessagePortDispatcher;\r\n})();\r\nvar WorkerEventDispatcher = (function() {\r\n  /**\r\n   * Created by Oleg Galaburda on 09.02.16.\r\n   */\r\n  \r\n  /* TODOs\r\n   * 1. implement transferList getter on passed event\r\n   */\r\n  var NOINIT = {};\r\n  \r\n  var Event = {};\r\n  \r\n  Object.defineProperties(Event, {\r\n    CONNECT: {\r\n      value: 'connect'\r\n    },\r\n    MESSAGE: {\r\n      value: 'message'\r\n    },\r\n    ERROR: {\r\n      value: 'error'\r\n    },\r\n    LANGUAGECHANGE: {\r\n      value: 'languagechange'\r\n    },\r\n    ONLINE: {\r\n      value: 'online'\r\n    },\r\n    OFFLINE: {\r\n      value: 'offline'\r\n    }\r\n  });\r\n  \r\n  function WorkerEvent(type, data, sourceEvent, client) {\r\n    EventDispatcher.Event.call(this, type, data);\r\n    this.sourceEvent = sourceEvent;\r\n    this.client = client;\r\n  }\r\n  WorkerEvent.createHandler = function(type, target, dispatcher) {\r\n    var eventType = WorkerEvent.getWorkerEventType(type);\r\n  \r\n    function handler(event) {\r\n      if (dispatcher.hasEventListener(eventType)) {\r\n        dispatcher.dispatchEvent(new WorkerEvent(eventType, event, event));\r\n      }\r\n    }\r\n  \r\n    target.addEventListener(type, handler);\r\n    return handler;\r\n  };\r\n  WorkerEvent.getWorkerEventType = function(type) {\r\n    var eventType = '';\r\n    switch (type) {\r\n      case Event.CONNECT:\r\n        eventType = WorkerEvent.CONNECT;\r\n        break;\r\n      case Event.MESSAGE:\r\n        eventType = WorkerEvent.MESSAGE;\r\n        break;\r\n      case Event.ERROR:\r\n        eventType = WorkerEvent.ERROR;\r\n        break;\r\n      case Event.LANGUAGECHANGE:\r\n        eventType = WorkerEvent.LANGUAGECHANGE;\r\n        break;\r\n      case Event.ONLINE:\r\n        eventType = WorkerEvent.ONLINE;\r\n        break;\r\n      case Event.OFFLINE:\r\n        eventType = WorkerEvent.OFFLINE;\r\n        break;\r\n    }\r\n    return eventType;\r\n  };\r\n  \r\n  Object.defineProperties(WorkerEvent, {\r\n    CONNECT: {\r\n      value: 'worker:connect'\r\n    },\r\n    MESSAGE: {\r\n      value: 'worker:message'\r\n    },\r\n    ERROR: {\r\n      value: 'worker:error'\r\n    },\r\n    LANGUAGECHANGE: {\r\n      value: 'worker:languagechange'\r\n    },\r\n    ONLINE: {\r\n      value: 'worker:online'\r\n    },\r\n    OFFLINE: {\r\n      value: 'worker:offline'\r\n    }\r\n  });\r\n  \r\n  var WorkerType = {};\r\n  Object.defineProperties(WorkerType, {\r\n    DEDICATED_WORKER: {\r\n      value: 'dedicated'\r\n    },\r\n    SHARED_WORKER: {\r\n      value: 'shared'\r\n    },\r\n    /**\r\n     * @private\r\n     */\r\n    SHARED_WORKER_SERVER: {\r\n      value: 'sharedServer'\r\n    },\r\n    /**\r\n     * @private\r\n     */\r\n    SHARED_WORKER_CLIENT: {\r\n      value: 'sharedClient'\r\n    }\r\n  });\r\n  \r\n  var WorkerMessenger = (function() {\r\n    /**\r\n     *\r\n     * @param port {Worker|MessagePort}\r\n     * @param receiverEventPreprocessor {?Function}\r\n     * @param senderEventPreprocessor {?Function}\r\n     * @extends MessagePortDispatcher\r\n     * @constructor\r\n     */\r\n    function WorkerMessenger(port, receiverEventPreprocessor, senderEventPreprocessor) {\r\n  \r\n      function postMessageHandler(data, transferList) {\r\n        port.postMessage(data, transferList);\r\n      }\r\n  \r\n      MessagePortDispatcher.call(this, port, postMessageHandler, receiverEventPreprocessor, senderEventPreprocessor);\r\n    }\r\n  \r\n    function setScopeHandlers(source, target) {\r\n      WorkerEvent.createHandler(Event.ERROR, source, target);\r\n      WorkerEvent.createHandler(Event.LANGUAGECHANGE, source, target);\r\n      WorkerEvent.createHandler(Event.ONLINE, source, target);\r\n      WorkerEvent.createHandler(Event.OFFLINE, source, target);\r\n    }\r\n  \r\n    WorkerMessenger.setScopeHandlers = setScopeHandlers;\r\n  \r\n    function setAbstractWorkerHandlers(source, target) {\r\n      WorkerEvent.createHandler(Event.ERROR, source, target);\r\n    }\r\n  \r\n    WorkerMessenger.setAbstractWorkerHandlers = setAbstractWorkerHandlers;\r\n    return WorkerMessenger;\r\n  })();\r\n  \r\n  /**\r\n   *\r\n   * @param worker\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @extends WorkerMessenger\r\n   * @constructor\r\n   */\r\n  function ServerEventDispatcher(target, receiverEventPreprocessor) {\r\n    var _target = target || self;\r\n    /**\r\n     * @type {EventDispatcher}\r\n     */\r\n    var _receiver = new EventDispatcher(receiverEventPreprocessor);\r\n  \r\n    function connectHandler(event) {\r\n      var client = WorkerEventDispatcher.create(\r\n        event.ports[0],\r\n        WorkerType.SHARED_WORKER_CLIENT\r\n      );\r\n      _receiver.dispatchEvent(new WorkerEvent(WorkerEvent.CONNECT, client, event, client));\r\n    }\r\n  \r\n    _target.addEventListener('connect', connectHandler);\r\n  \r\n    this.addEventListener = _receiver.addEventListener;\r\n    this.hasEventListener = _receiver.hasEventListener;\r\n    this.removeEventListener = _receiver.removeEventListener;\r\n    this.removeAllEventListeners = _receiver.removeAllEventListeners;\r\n  \r\n    WorkerMessenger.setScopeHandlers(_target, _receiver);\r\n  \r\n    Object.defineProperties(this, {\r\n      receiver: {\r\n        value: _receiver\r\n      },\r\n      target: {\r\n        value: _target\r\n      }\r\n    });\r\n  }\r\n  ServerEventDispatcher.prototype = new WorkerEventDispatcher(NOINIT, WorkerType.SHARED_WORKER_SERVER);\r\n  ServerEventDispatcher.prototype.constructor = ServerEventDispatcher;\r\n  \r\n  /**\r\n   * @param port {MessagePort}\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @extends WorkerMessenger\r\n   * @constructor\r\n   */\r\n  function ClientEventDispatcher(port, receiverEventPreprocessor, senderEventPreprocessor) {\r\n    function start() {\r\n      port.start();\r\n    }\r\n  \r\n    function close() {\r\n      port.close();\r\n    }\r\n  \r\n    WorkerMessenger.call(this, port, receiverEventPreprocessor, senderEventPreprocessor);\r\n  \r\n    this.start = start;\r\n    this.close = close;\r\n  }\r\n  ClientEventDispatcher.prototype = new WorkerEventDispatcher(NOINIT, WorkerType.SHARED_WORKER_CLIENT);\r\n  ClientEventDispatcher.prototype.constructor = ClientEventDispatcher;\r\n  \r\n  /**\r\n   *\r\n   * @param worker {SharedWorker}\r\n   * @param name {String}\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @extends WorkerMessenger\r\n   * @constructor\r\n   */\r\n  function SharedWorkerEventDispatcher(worker, name, receiverEventPreprocessor, senderEventPreprocessor) {\r\n    var _target = worker;\r\n    if (!EventDispatcher.isObject(worker)) {\r\n      _target = new SharedWorker(String(worker), name);\r\n    }\r\n  \r\n    ClientEventDispatcher.call(this, _target.port, receiverEventPreprocessor, senderEventPreprocessor);\r\n    WorkerMessenger.setAbstractWorkerHandlers(_target, this.receiver);\r\n  }\r\n  SharedWorkerEventDispatcher.prototype = new WorkerEventDispatcher(NOINIT, WorkerType.SHARED_WORKER);\r\n  SharedWorkerEventDispatcher.prototype.constructor = SharedWorkerEventDispatcher;\r\n  \r\n  /**\r\n   *\r\n   * @param worker {Worker|String}\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @extends WorkerMessenger\r\n   * @constructor\r\n   */\r\n  function DedicatedWorkerEventDispatcher(worker, receiverEventPreprocessor, senderEventPreprocessor) {\r\n    var _target = worker || self;\r\n  \r\n    if (!EventDispatcher.isObject(_target)) {\r\n      _target = new Worker(String(worker));\r\n    }\r\n  \r\n    WorkerMessenger.call(this, _target, receiverEventPreprocessor, senderEventPreprocessor);\r\n    WorkerMessenger.setScopeHandlers(_target, this.receiver);\r\n  \r\n    function terminate() {\r\n      return _target.terminate();\r\n    }\r\n  \r\n    this.terminate = terminate;\r\n  }\r\n  DedicatedWorkerEventDispatcher.prototype = new WorkerEventDispatcher(NOINIT, WorkerType.DEDICATED_WORKER);\r\n  DedicatedWorkerEventDispatcher.prototype.constructor = DedicatedWorkerEventDispatcher;\r\n  \r\n  /**\r\n   *\r\n   * @param worker {String|Worker}\r\n   * @param type {String}\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @extends WorkerMessenger\r\n   * @constructor\r\n   */\r\n  function WorkerEventDispatcher(worker, type, receiverEventPreprocessor, senderEventPreprocessor) {\r\n    if (worker === NOINIT) {\r\n      Object.defineProperties(this, {\r\n        type: {\r\n          value: type\r\n        }\r\n      });\r\n    } else {\r\n      DedicatedWorkerEventDispatcher.call(this, worker, receiverEventPreprocessor, senderEventPreprocessor);\r\n    }\r\n  }\r\n  \r\n  WorkerEventDispatcher.WorkerEvent = WorkerEvent;\r\n  WorkerEventDispatcher.WorkerType = WorkerType;\r\n  \r\n  WorkerEventDispatcher.Dedicated = DedicatedWorkerEventDispatcher;\r\n  WorkerEventDispatcher.Shared = SharedWorkerEventDispatcher;\r\n  WorkerEventDispatcher.Server = ServerEventDispatcher;\r\n  WorkerEventDispatcher.Client = ClientEventDispatcher;\r\n  \r\n  /**\r\n   *\r\n   * @param worker {String|Worker|SharedWorker|MessagePort}\r\n   * @param type {String}\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @returns {WorkerEventDispatcher}\r\n   */\r\n  WorkerEventDispatcher.create = function(target, type, receiverEventPreprocessor, senderEventPreprocessor) {\r\n    var dispatcher = null;\r\n    switch (type) {\r\n      default:\r\n      case WorkerType.DEDICATED_WORKER:\r\n        dispatcher = new DedicatedWorkerEventDispatcher(target, receiverEventPreprocessor, senderEventPreprocessor);\r\n        break;\r\n      case WorkerType.SHARED_WORKER:\r\n        dispatcher = new SharedWorkerEventDispatcher(target, null, receiverEventPreprocessor, senderEventPreprocessor);\r\n        break;\r\n      case WorkerType.SHARED_WORKER_SERVER:\r\n        dispatcher = new ServerEventDispatcher(target, receiverEventPreprocessor);\r\n        break;\r\n      case WorkerType.SHARED_WORKER_CLIENT:\r\n        dispatcher = new ClientEventDispatcher(target, receiverEventPreprocessor, senderEventPreprocessor);\r\n        break;\r\n    }\r\n    return dispatcher;\r\n  }\r\n  \r\n  /**\r\n   *\r\n   * @param receiverEventPreprocessor {?Function}\r\n   * @param senderEventPreprocessor {?Function}\r\n   * @returns {WorkerEventDispatcher}\r\n   */\r\n  WorkerEventDispatcher.self = function(receiverEventPreprocessor, senderEventPreprocessor) {\r\n    var dispatcher = null;\r\n    if (typeof(self.postMessage) === 'function') {\r\n      dispatcher = new DedicatedWorkerEventDispatcher(self, receiverEventPreprocessor, senderEventPreprocessor);\r\n    } else {\r\n      dispatcher = new ServerEventDispatcher(self, receiverEventPreprocessor);\r\n    }\r\n    return dispatcher;\r\n  };\r\n  \r\n  return WorkerEventDispatcher;\r\n})();\r\n",
    INTERFACE_SRC:"/**\r\n * Created by Oleg Galaburda on 25.02.16.\r\n */\r\nvar WorkerInterface;\r\nfunction generateWorkerBlobData(importScriptURLs) {\r\n  importScriptURLs = importScriptURLs instanceof Array ? importScriptURLs : [String(importScriptURLs)];\r\n  var length = importScriptURLs.length;\r\n  for (var index = 0; index < length; index++) {\r\n    importScriptURLs[index] = WorkerInterface.fullImportScriptURL(importScriptURLs[index]);\r\n  }\r\n  return generateBlob([\r\n    Scripts.DEPS_SRC,\r\n    Scripts.INTERFACE_SRC,\r\n    Scripts.SELF_SRC.replace('{$}', importScriptURLs.join('\", \"'))\r\n  ], 'text/javascript;charset=UTF-8');\r\n}\r\n\r\nfunction generateBlob(data, type) {\r\n  var blob = new Blob(data instanceof Array ? data : [data], {type: type || 'text/plain;charset=UTF-8'});\r\n  return window.URL.createObjectURL(blob);\r\n}\r\n\r\nfunction fullImportScriptURL(path) {\r\n  if (path.search(/^\\w+\\:\\/\\//) >= 0) return path;\r\n  var fullPath = window.location.origin;\r\n  var dirs = window.location.pathname.match(/([^\\/\\\\]+)(?:\\/|\\\\)+/g);\r\n  if (path.charAt() === '/') {\r\n    fullPath += path;\r\n  } else if (path.substr(0, 3) === '../') {\r\n    var pathDirs = path.match(/([^\\/\\\\]+)(?:\\/|\\\\)+/g);\r\n    while (pathDirs.length && dirs.length && pathDirs[0] === '../') {\r\n      pathDirs.shift();\r\n      dirs.pop();\r\n    }\r\n    fullPath += '/' + dirs.join('') + pathDirs.join('') + path.match(/[^\\/\\\\]*$/g)[0];\r\n  } else if (path.substr(0, 2) === './') {\r\n    fullPath += '/' + dirs.join('') + path.substring(2);\r\n  } else {\r\n    fullPath += '/' + dirs.join('') + path;\r\n  }\r\n  return fullPath;\r\n}\r\n\r\nfunction isStandalone() {\r\n  return typeof(Scripts) !== 'undefined' && Scripts.hasOwnProperty('SELF_SRC');\r\n};\r\n\r\nvar CommandType = {\r\n  GET: 'get',\r\n  SET: 'set',\r\n  CALL: 'call',\r\n  EXEC: 'exec',\r\n  DESTROY_TARGET: 'destroyTarget'\r\n};\r\n\r\nvar Events = {\r\n  READY_EVENT: '~WI:Ready',\r\n  REQUEST_EVENT: '~WI:Request',\r\n  RESPONSE_EVENT: '~WI:Response',\r\n  internals: {\r\n    //'~WI:Request': true, // we need to receive already created wrapper object and resolved dependencies to execute commands\r\n    '~WI:Response': true // here we receive only metadata because wrapper objects are already created with promises\r\n  }\r\n};\r\n\r\nvar ResponseTypes = {\r\n  RESULT_SUCCESS: 'success',\r\n  RESULT_FAILURE: 'failure'\r\n};\r\n\r\nvar getId = (function() {\r\n  var _base = 'WI/' + String(Date.now()) + '/';\r\n  var _index = 0;\r\n  return function() {\r\n    return _base + String(++_index) + '/' + String(Date.now());\r\n  };\r\n})();\r\n\r\nvar createDeferred = (function() {\r\n  function Deferred() {\r\n    this.promise = new Promise(function(resolve, reject) {\r\n      this.resolve = resolve;\r\n      this.reject = reject;\r\n    }.bind(this));\r\n  }\r\n\r\n  function createDeferred() {\r\n    return new Deferred();\r\n  }\r\n\r\n  return createDeferred;\r\n})();\r\n\r\n//TODO If RequestTarget, RequestTargetLink or their proxies are passed, they should be converted to RAW links.\r\nvar DataConverter = (function() {\r\n\r\n  function convertLinkToRaw(data) {\r\n    if (typeof(data.toJSON) === 'function') {\r\n      data = data.toJSON();\r\n    }\r\n    return data;\r\n  }\r\n\r\n  function convertRawToRequestTarget(data, sendRequestHandler) {\r\n    var poolId = RequestTargetLink.getLinkPoolId(data);\r\n    if (poolId === TargetPool.instance.id) { // target object is stored in current pool\r\n      data = TargetPool.instance.get(RequestTargetLink.getLinkId(data));\r\n      if (data) {\r\n        data = data.target;\r\n      }\r\n    } else { // target object has another origin, should be wrapped\r\n      data = new RequestTarget(Promise.resolve(data), sendRequestHandler);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  function convertArrayTo(list, linkConvertHandler, sendRequestHandler) {\r\n    var result = [];\r\n    var length = list.length;\r\n    for (var index = 0; index < length; index++) {\r\n      var value = list[index];\r\n      if (RequestTargetLink.isLink(value)) {\r\n        result[index] = linkConvertHandler(value, sendRequestHandler);\r\n      } else {\r\n        result[index] = value;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function convertHashTo(data, linkConvertHandler, sendRequestHandler) {\r\n    var result = {};\r\n    for (var name in data) {\r\n      if (!data.hasOwnProperty(name)) continue;\r\n      var value = data[name];\r\n      if (RequestTargetLink.isLink(data)) {\r\n        result[name] = linkConvertHandler(value, sendRequestHandler);\r\n      } else {\r\n        result[name] = value;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function convertToRaw(data) {\r\n    var result = data;\r\n    var dataType = typeof(data);\r\n    if (dataType === 'object' && data !== null) {\r\n      if (RequestTargetLink.isLink(data)) { // if data is link\r\n        result = convertLinkToRaw(data);\r\n      } else if (data instanceof Array) { // if data is Array of values, check its\r\n        result = convertArrayTo(data, convertLinkToRaw);\r\n      } else if (data.constructor === Object) { // only Object instances can be looked up, other object types must be converted by hand\r\n        result = convertHashTo(data, convertLinkToRaw);\r\n      }\r\n    } else if (dataType === 'function') {\r\n      result = TargetPool.instance.set(data).toJSON();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function prepareToSend(data) {\r\n    if (data) {\r\n      data.value = convertToRaw(data.value);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  function convertFromRaw(data, sendRequestHandler) {\r\n    var result = data;\r\n    if (typeof(data) === 'object' && data !== null) {\r\n      if (RequestTargetLink.isLink(data)) { // if data is link\r\n        result = convertRawToRequestTarget(data, sendRequestHandler);\r\n      } else if (data instanceof Array) { // if data is Array of values, check its\r\n        result = convertArrayTo(data, convertRawToRequestTarget, sendRequestHandler);\r\n      } else if (data.constructor === Object) {\r\n        result = convertHashTo(data, convertRawToRequestTarget, sendRequestHandler);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function prepareToReceive(data, sendRequestHandler) {\r\n    if (data) {\r\n      data.value = convertFromRaw(data.value, sendRequestHandler);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  function isPending(value) {\r\n    return value instanceof RequestTarget && value.target.status == TargetStatus.PENDING;\r\n  }\r\n\r\n  function lookupForPending(data) {\r\n    var result = [];\r\n    if (typeof(data) === 'object' && data !== null) {\r\n      function add(value) {\r\n        if (isPending(value)) {\r\n          result.push(value);\r\n        }\r\n        return value;\r\n      }\r\n      if (isPending(data)) {\r\n        result.push(data);\r\n      } else if (data instanceof Array) {\r\n        convertArrayTo(data, add);\r\n      } else if (data.constructor === Object) {\r\n        convertHashTo(data, add);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    prepareToSend: prepareToSend,\r\n    prepareToReceive: prepareToReceive,\r\n    lookupForPending: lookupForPending\r\n  };\r\n})();\r\n\r\nfunction evaluateRequest(type, cmd, value, target) {\r\n  var handler, result = undefined;\r\n  switch (type) {\r\n    case CommandType.CALL:\r\n      with (target) {\r\n        if (cmd) {\r\n          eval('handler = ' + cmd);\r\n          result = handler.apply(target, value);\r\n        } else {\r\n          //FIXME Find way to pass function context\r\n          result = target.apply(null, value);\r\n        }\r\n      }\r\n      break;\r\n    case CommandType.EXEC:\r\n      with (target) {\r\n        eval('result = (function(target) { with(target){ return ' + cmd + '; }})(target);');\r\n        /*\r\n         eval('result = ' + cmd);\r\n         */\r\n      }\r\n      break;\r\n    case CommandType.GET:\r\n      with (target) {\r\n        eval('result = ' + cmd);\r\n      }\r\n      break;\r\n    case CommandType.SET:\r\n      eval('handler = function(value, target) { with(target) { ' + cmd + ' = value; } };');\r\n      handler(value, target);\r\n      /*\r\n       handler = new Function('value,target', 'with(target){ ' + cmd + ' = value; }');\r\n       handler(value, target);\r\n       */\r\n      break;\r\n    case CommandType.DESTROY_TARGET:\r\n      TargetPool.instance.remove(target);\r\n      break;\r\n  }\r\n  return result;\r\n}\r\n\r\nvar TargetStatus = {\r\n  PENDING: 'pending',\r\n  RESOLVED: 'resolved',\r\n  REJECTED: 'rejected',\r\n  DESTROYED: 'destroyed'\r\n};\r\n//FIXME Make an internal class of objects that will hold all of internal functionality & data of the RequestTarget and will never be exposed to public\r\n// RequestTarget<>-------RequestTargetInternals\r\n// This will help by moving all of RequestTarget internal methods to RequestTargetInternals prototype\r\n// Also try to use Symbols for naming, might help with hiding private members\r\nvar RequestTarget = (function() {\r\n\r\n  function _createRequestPackage(type, cmd, value, targetId) {\r\n    return pack = {\r\n      type: type,\r\n      cmd: cmd,\r\n      value: value,\r\n      target: targetId\r\n    };\r\n  }\r\n\r\n  function _applyRequest(pack, deferred) {\r\n    var promise = deferred.promise;\r\n    switch (this.status) {\r\n      case TargetStatus.PENDING:\r\n        this._addToQueue(pack, deferred);\r\n        break;\r\n      case TargetStatus.REJECTED:\r\n        promise = Promise.reject(new Error('Target object was rejected and cannot be used for calls.'));\r\n        break;\r\n      case TargetStatus.DESTROYED:\r\n        promise = Promise.reject(new Error('Target object was destroyed and cannot be used for calls.'));\r\n        break;\r\n      case TargetStatus.RESOLVED:\r\n        //this._sendRequestHandler(pack, deferred);\r\n        this._sendRequestHandlerPrecondition(pack, deferred);\r\n        break;\r\n    }\r\n    return promise;\r\n  }\r\n\r\n  function _sendRequestHandlerPrecondition(pack, deferred) {\r\n    var list = DataConverter.lookupForPending(pack.value);\r\n    if (list.length) {\r\n      // FIXME Need to test on all platforms: In other browsers this might not work because may need list of Promise objects, not RequestTargets\r\n      Promise.all(list).then(function() {\r\n        this._sendRequestHandler(pack, deferred);\r\n      }.bind(this));\r\n    } else {\r\n      this._sendRequestHandler(pack, deferred);\r\n    }\r\n  }\r\n\r\n  function _sendRequest(type, cmd, value) {\r\n    var pack = _createRequestPackage(type, cmd, value, this.id);\r\n    var promise = this._applyRequest(pack, createDeferred());\r\n    return new RequestTarget(promise, this._sendRequestHandler);\r\n  }\r\n\r\n  function _get(path) {\r\n    return this._sendRequest(CommandType.GET, path);\r\n  }\r\n\r\n  function _set(path, value) {\r\n    return this._sendRequest(CommandType.SET, path, value);\r\n  }\r\n\r\n  function _call(path, args) {\r\n    if (!args) {\r\n      args = [];\r\n    } else if (!(args instanceof Array)) {\r\n      args = [args];\r\n    }\r\n    return this._sendRequest(CommandType.CALL, path, args);\r\n  }\r\n\r\n  function _execute(command) {\r\n    return this._sendRequest(CommandType.EXEC, command);\r\n  }\r\n\r\n  function _isActive() {\r\n    return this.status === TargetStatus.PENDING || this.status === TargetStatus.RESOLVED;\r\n  }\r\n\r\n  function _canBeDestroyed() {\r\n    return this.id && this.status === TargetStatus.RESOLVED;\r\n  }\r\n\r\n  function _toJSON() {\r\n    return {\r\n      _targetLink_: {\r\n        id: this.id,\r\n        type: this.targetType,\r\n        poolId: this.poolId\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The object that will be available on other side\r\n   * IMPORTANT: Function target is temporary if queue contains single CALL command when target is resolved.\r\n   * @param _promise\r\n   * @param sendRequestHandler\r\n   * @constructor\r\n   */\r\n  function RequestTarget(_promise, sendRequestHandler) {\r\n    var _this = this;\r\n    var _link;\r\n    var _temporary;\r\n    var _hadChildPromises = false;\r\n    var _status = TargetStatus.PENDING;\r\n    var _queue = [];\r\n\r\n    Object.defineProperties(this, {\r\n      id: {\r\n        get: function() {\r\n          return _link ? _link.id : null;\r\n        },\r\n        configurable: true\r\n      },\r\n      target: {\r\n        get: function() {\r\n          return _this;\r\n        }\r\n      },\r\n      targetType: {\r\n        get: function() {\r\n          return _link ? _link.type : null;\r\n        },\r\n        configurable: true\r\n      },\r\n      poolId: {\r\n        get: function() {\r\n          return _link ? _link.poolId : null;\r\n        },\r\n        configurable: true\r\n      },\r\n      temporary: {\r\n        get: function() {\r\n          return _temporary;\r\n        },\r\n        //INFO User can set permanent/temporary by hand\r\n        set: function(value) {\r\n          if (this.isActive()) {\r\n            _temporary = Boolean(value);\r\n            if (_status == TargetStatus.RESOLVED) {\r\n              this.destroy();\r\n            }\r\n          }\r\n        }\r\n      },\r\n      status: {\r\n        get: function() {\r\n          return _status;\r\n        },\r\n        configurable: true\r\n      },\r\n      _sendRequestHandler: {\r\n        value: sendRequestHandler,\r\n        configurable: true\r\n      },\r\n      _targetLink_: {\r\n        value: this\r\n      }\r\n    });\r\n\r\n    function _destroy() {\r\n      var promise = null;\r\n      if (_this.canBeDestroyed()) {\r\n        _status = TargetStatus.DESTROYED;\r\n        promise = _this._sendRequest(CommandType.DESTROY_TARGET);\r\n      } else {\r\n        promise = Promise.reject();\r\n      }\r\n      return promise;\r\n    }\r\n\r\n    function _isTemporary(value) {\r\n      /* TODO this case for Proxies, may be check for proxies support? this will work only if Proxies are enabled.\r\n       For functions, they are temporary only if they have only CALL command in queue and child promises never created -- this commonly means that this target was used for function call in proxy.\r\n       For any non-function target object, it will be marked as temporary only if has single item in request queue and child promises never created.\r\n       */\r\n      var temp = _temporary;\r\n      if (typeof(temp) !== 'boolean') {\r\n        if (RequestTargetLink.getLinkTargetType(value) === 'function') {\r\n          temp = _queue && _queue.length === 1 && _queue[0][0].type == CommandType.CALL && !_hadChildPromises;\r\n        } else {\r\n          temp = (_queue && _queue.length === 1 && !_hadChildPromises);\r\n        }\r\n      }\r\n      return temp;\r\n    }\r\n\r\n    function _resolveHandler(value) {\r\n      _status = TargetStatus.RESOLVED;\r\n      if (RequestTargetLink.isLink(value)) {\r\n        _link = RequestTargetLink.getLinkData(value);\r\n        _temporary = _isTemporary(value);\r\n        if (_temporary) {\r\n          _queue[_queue.length - 1][1].promise.then(_destroy, _destroy);\r\n        }\r\n        //INFO Sending \"this\" as result of resolve() handler, causes infinite loop of this.then(), so I've used wrapper object\r\n        value = {target: _this};\r\n      }\r\n      _sendQueue();\r\n      return value;\r\n    }\r\n\r\n    function _sendQueue() {\r\n      while (_queue && _queue.length) {\r\n        var request = _queue.shift();\r\n        var pack = request[0];\r\n        var deferred = request[1];\r\n        pack.target = _link.id;\r\n        //_this._sendRequestHandler(pack, deferred);\r\n        _this._sendRequestHandlerPrecondition(pack, deferred);\r\n      }\r\n      _queue = null;\r\n    }\r\n\r\n    function _rejectHandler(value) {\r\n      _status = TargetStatus.REJECTED;\r\n      while (_queue && _queue.length) {\r\n        var request = _queue.shift();\r\n        request[1].reject(new Error('Target of the call was rejected and callcannot be sent.'));\r\n      }\r\n      _queue = null;\r\n      return value;\r\n    }\r\n\r\n    function _then(success, fail) {\r\n      var child = _promise.then(success, fail);\r\n      //var child = _promise.then.apply(_promise, arguments);\r\n      if (child) {\r\n        _hadChildPromises = true;\r\n      }\r\n      return child;\r\n    }\r\n\r\n    function _catch() {\r\n      var child = _promise.catch.apply(_promise, arguments);\r\n      if (child) {\r\n        _hadChildPromises = true;\r\n      }\r\n      return child;\r\n    }\r\n\r\n    function _addToQueue(pack, deferred) {\r\n      _queue.push([pack, deferred]);\r\n    }\r\n\r\n    _promise = _promise.then(_resolveHandler, _rejectHandler);\r\n\r\n    this._addToQueue = _addToQueue;\r\n    this.then = _then;\r\n    this.catch = _catch;\r\n    this.destroy = _destroy;\r\n  }\r\n\r\n  RequestTarget.prototype.get = _get;\r\n  RequestTarget.prototype.set = _set;\r\n  RequestTarget.prototype.call = _call;\r\n  RequestTarget.prototype.execute = _execute;\r\n  RequestTarget.prototype.canBeDestroyed = _canBeDestroyed;\r\n  RequestTarget.prototype.isActive = _isActive;\r\n  RequestTarget.prototype.toJSON = _toJSON;\r\n  RequestTarget.prototype._sendRequest = _sendRequest;\r\n  RequestTarget.prototype._applyRequest = _applyRequest;\r\n  RequestTarget.prototype._sendRequestHandlerPrecondition = _sendRequestHandlerPrecondition;\r\n\r\n  return RequestTarget;\r\n})();\r\n\r\n\r\nvar RequestTargetLink = (function() {\r\n  /**\r\n   * The object that can be used to send Target to other side\r\n   * @constructor\r\n   */\r\n  function RequestTargetLink(_pool, _target, _id) {\r\n    var _active = true;\r\n    Object.defineProperties(this, {\r\n      poolId: {\r\n        get: function() {\r\n          return _pool ? _pool.id : null;\r\n        }\r\n      },\r\n      target: {\r\n        get: function() {\r\n          return _target;\r\n        }\r\n      },\r\n      id: {\r\n        get: function() {\r\n          return _id;\r\n        }\r\n      },\r\n      _targetLink_: {\r\n        value: this\r\n      }\r\n    });\r\n    this.destroy = function() {\r\n      if (!_active) return;\r\n      _active = false;\r\n      _id = null;\r\n      _pool = null;\r\n      _target = null;\r\n      _pool.remove(_id);\r\n    };\r\n  }\r\n\r\n  RequestTargetLink.prototype.toJSON = function() {\r\n    return {\r\n      _targetLink_: {\r\n        id: this.id,\r\n        type: typeof(this.target),\r\n        poolId: this.poolId\r\n      }\r\n    };\r\n  };\r\n\r\n  RequestTargetLink.getLink = function(id) {\r\n    return {\r\n      _targetLink_: {\r\n        id: id || 0,\r\n        poolId: TargetPool.instance.id\r\n      }\r\n    };\r\n  };\r\n\r\n  RequestTargetLink.getLinkData = function(object) {\r\n    var data;\r\n    if (RequestTargetLink.isLink(object)) {\r\n      data = object._targetLink_;\r\n    }\r\n    return data;\r\n  };\r\n\r\n  RequestTargetLink.getLinkId = function(object) {\r\n    var id;\r\n    if (RequestTargetLink.isLink(object)) {\r\n      id = object._targetLink_.id;\r\n    }\r\n    return id;\r\n  };\r\n\r\n  RequestTargetLink.getLinkPoolId = function(object) {\r\n    var poolId;\r\n    if (RequestTargetLink.isLink(object)) {\r\n      poolId = object._targetLink_.poolId;\r\n    }\r\n    return poolId;\r\n  };\r\n\r\n  RequestTargetLink.getLinkTargetType = function(object) {\r\n    var type;\r\n    if (RequestTargetLink.isLink(object)) {\r\n      type = object._targetLink_.type;\r\n    }\r\n    return type;\r\n  };\r\n\r\n  RequestTargetLink.isLink = function(object) {\r\n    return typeof(object) === 'object' && typeof(object._targetLink_) === 'object' && object._targetLink_;\r\n  };\r\n\r\n  return RequestTargetLink;\r\n})();\r\n\r\n// TargetPool must have globally available instance, so many WorkerInterface instances can use it. Might be helpful for SharedWorker serve\\r.\r\nfunction TargetPool() {\r\n  var _map = new Map();\r\n  this.set = function(target) {\r\n    var link = null;\r\n    if (TargetPool.isValidTarget(target)) {\r\n      if (_map.has(target)) {\r\n        link = _map.get(target);\r\n      } else {\r\n        var id = getId();\r\n        link = new RequestTargetLink(this, target, id);\r\n        _map.set(id, link);\r\n        _map.set(target, link);\r\n      }\r\n    }\r\n    return link;\r\n  };\r\n\r\n  this.has = function(target) {\r\n    return _map.has(target);\r\n  };\r\n\r\n  this.get = function(target) {\r\n    return _map.get(target);\r\n  };\r\n\r\n  this.remove = function(target) {\r\n    var link = _map.get(target);\r\n    if (link) {\r\n      _map.delete(link.id);\r\n      _map.delete(link.target);\r\n      link.destroy();\r\n    }\r\n  };\r\n\r\n  this.clear = function() {\r\n    var list = _map.keys();\r\n    var length = list.length;\r\n    for (var index = 0; index < length; index++) {\r\n      var key = list[index];\r\n      if (typeof(key) === 'string') {\r\n        var link = _map.get(key);\r\n        link.destroy();\r\n      }\r\n    }\r\n    _map.clear();\r\n  };\r\n\r\n  Object.defineProperties(this, {\r\n    id: {\r\n      value: getId()\r\n    }\r\n  });\r\n}\r\n\r\nTargetPool.isValidTarget = (function() {\r\n  var valid = {\r\n    'object': true,\r\n    'function': true\r\n  };\r\n  return function(target) {\r\n    return target && valid[typeof(target)];\r\n  };\r\n})();\r\n\r\nObject.defineProperties(TargetPool, {\r\n  instance: {\r\n    value: new TargetPool()\r\n  }\r\n});\r\n\r\n//FIXME WorkerInterface success handler received its internal RequestTarget instance but should receive interface instance.\r\nfunction WorkerInterfaceBase(importScriptURL, type) {\r\n  var _dispatcher = null;\r\n  var _deferred = createDeferred();\r\n  var _target = new RequestTarget(_deferred.promise, sendRequest);\r\n  // Default target for requests\r\n  var _pool = {};\r\n  /*\r\n   FIFO queue for requests that were made before interface become ready.\r\n   */\r\n  if (importScriptURL) {\r\n    if (isStandalone()) {\r\n      _dispatcher = WorkerEventDispatcher.create(generateWorkerBlobData(importScriptURL), type || WorkerInterface.DEDICATED, receiverEventPreprocessor, senderEventPreprocessor);\r\n    } else {\r\n      _dispatcher = WorkerEventDispatcher.create(importScriptURL, type || WorkerInterface.DEDICATED, receiverEventPreprocessor, senderEventPreprocessor);\r\n    }\r\n    _dispatcher.addEventListener(Events.READY_EVENT, readyEventHandler);\r\n  } else {\r\n    _dispatcher = WorkerEventDispatcher.self(receiverEventPreprocessor, senderEventPreprocessor);\r\n    _dispatcher.dispatchEvent(Events.READY_EVENT);\r\n    readyEventHandler();\r\n  }\r\n\r\n\r\n  var _requests = {};\r\n\r\n  function readyEventHandler() {\r\n    _dispatcher.removeEventListener(Events.READY_EVENT, readyEventHandler);\r\n    _deferred.resolve(RequestTargetLink.getLink(''));\r\n  }\r\n\r\n  function requestEventHandler(event) {\r\n    var result, target;\r\n    var data = event.data;  // {type:string, id:string, cmd:string, value:any, target: string\r\n    try {\r\n      target = data.target ? TargetPool.instance.get(data.target) : _pool;\r\n      // data.value should be preprocessed in evaluateRequest\r\n      result = evaluateRequest(data.type, data.cmd, data.value, target);\r\n    } catch (error) {\r\n      sendResponse({\r\n        name: error.name,\r\n        message: error.message\r\n      }, ResponseTypes.RESULT_FAILURE, data.id);\r\n      throw error;\r\n    }\r\n    if (result instanceof Promise) {\r\n      handlePromiseResponse(result, data.id);\r\n    } else {\r\n      sendResponse(result, ResponseTypes.RESULT_SUCCESS, data.id);\r\n    }\r\n  }\r\n\r\n  function handlePromiseResponse(promise, id) {\r\n    promise.then(\r\n      function(result) {\r\n        sendResponse(result, ResponseTypes.RESULT_SUCCESS, id);\r\n      },\r\n      function(result) {\r\n        sendResponse(result, ResponseTypes.RESULT_FAILURE, id);\r\n      }\r\n    );\r\n  }\r\n\r\n  function responseEventHandler(event) {\r\n    var data = event.data; // {type:string, id:string, value:any}\r\n    var deferred = _requests[data.id];\r\n    delete _requests[data.id];\r\n    switch (data.type) {\r\n      default:\r\n        throw new Error('Unknown package received:' + JSON.stringify(event));\r\n        break;\r\n      case ResponseTypes.RESULT_FAILURE:\r\n        deferred.reject(data.value);\r\n        break;\r\n      case ResponseTypes.RESULT_SUCCESS:\r\n        deferred.resolve(data.value);\r\n        break;\r\n    }\r\n  }\r\n\r\n  function receiverEventPreprocessor(event) {\r\n    /* INFO Regenerate event since data might be read-only? Might be data loss in case of inocrrent cloning\r\n     event.data = DataConverter.prepareToReceive(event.data);\r\n     return event;\r\n     */\r\n    if (!Events.internals[event.type]) {\r\n      event = {\r\n        type: event.type,\r\n        data: DataConverter.prepareToReceive(event.data, sendRequest)\r\n      };\r\n    }\r\n    return event;\r\n  }\r\n\r\n  function senderEventPreprocessor(event) {\r\n    /* INFO Regenerate event since data might be read-only? Might be data loss in case of inocrrent cloning\r\n     event.data = DataConverter.prepareToSend(event.data);\r\n     return event;\r\n     */\r\n    return {\r\n      type: event.type,\r\n      data: DataConverter.prepareToSend(event.data)\r\n    };\r\n  }\r\n\r\n  function sendRequest(pack, deferred) {\r\n    var id = getId();\r\n    pack.id = id;\r\n    pack.value = DataConverter.prepareToSend(pack.value);\r\n    deferred = deferred || createDeferred(id);\r\n    _requests[id] = deferred;\r\n    _dispatcher.dispatchEvent(Events.REQUEST_EVENT, pack);\r\n    return deferred.promise;\r\n  }\r\n\r\n  function sendResponse(data, type, id) {\r\n    var result = {\r\n      id: id,\r\n      type: type,\r\n      value: data\r\n    };\r\n    _dispatcher.dispatchEvent(Events.RESPONSE_EVENT, result);\r\n  }\r\n\r\n\r\n// RequestTarget methods\r\n  this.get = _target.get.bind(_target);\r\n  this.set = _target.set.bind(_target);\r\n  this.call = _target.call.bind(_target);\r\n  this.execute = _target.execute.bind(_target);\r\n  // RequestTarget Promise methods\r\n  this.then = _target.then;\r\n  this.catch = _target.catch;\r\n\r\n  Object.defineProperties(this, {\r\n    dispatcher: {\r\n      value: _dispatcher\r\n    },\r\n    target: {\r\n      value: this\r\n    },\r\n    pool: {\r\n      get: function() {\r\n        return _pool;\r\n      },\r\n      set: function(value) {\r\n        _pool = value;\r\n      }\r\n    }\r\n  });\r\n\r\n  _dispatcher.addEventListener(Events.REQUEST_EVENT, requestEventHandler);\r\n  _dispatcher.addEventListener(Events.RESPONSE_EVENT, responseEventHandler);\r\n}\r\n\r\nif (typeof(Proxy) === 'function') {\r\n  WorkerInterface = (function() {\r\n    function createHandlers(exclustions) {\r\n      return {\r\n        'get': function(wrapper, name) {\r\n          var value;\r\n          if (exclustions[name]) {\r\n            value = wrapper.target[name];\r\n          } else {\r\n            var child = wrapper.target.get(name);\r\n  \r\n            function childTargetWrapper() {\r\n              return child;\r\n            }\r\n  \r\n            childTargetWrapper.target = child;\r\n            value = createRequestTargetProxy(childTargetWrapper);\r\n          }\r\n          return value;\r\n        },\r\n        'apply': function(wrapper, thisValue, args) {\r\n          return createRequestTargetProxy(wrapper.target.call(null, args));\r\n        },\r\n        'set': function(wrapper, name, value) {\r\n          var result;\r\n          if (exclustions[name]) {\r\n            result = wrapper.target[name] = value;\r\n          } else {\r\n            result = wrapper.target.set(name, value);\r\n          }\r\n          return result;\r\n        },\r\n        'has': function(wrapper, name) {\r\n          return Boolean(exclustions[name]);\r\n        },\r\n        'deleteProperty': function(wrapper, name) {\r\n          return false;\r\n        },\r\n        'ownKeys': function(wrapper) {\r\n          return [];\r\n        }\r\n      };\r\n    }\r\n  \r\n    // Look if toJSON should be added to allowed\r\n    var RequestTargetAllowed = {\r\n      'target': true,\r\n      'then': true,\r\n      'catch': true,\r\n      '_targetLink_': true,\r\n      'toJSON': true\r\n    };\r\n  \r\n    var RequestTargetHandlers = createHandlers(RequestTargetAllowed);\r\n  \r\n    var WorkerInterfaceAllowed = {\r\n      'get': true,\r\n      'set': true,\r\n      'call': true,\r\n      'execute': true,\r\n      'target': true,\r\n      'dispatcher': true,\r\n      'then': true,\r\n      'catch': true,\r\n      'pool': true\r\n    };\r\n  \r\n    var WorkerInterfaceHandlers = createHandlers(WorkerInterfaceAllowed);\r\n  \r\n    function createRequestTargetProxy(wrapper) {\r\n      return new Proxy(wrapper, RequestTargetHandlers);\r\n    }\r\n  \r\n    var WorkerInterface = new Proxy(WorkerInterfaceBase, {\r\n      'construct': function(targetDefinition, args) {\r\n        var target = new targetDefinition(args[0], args[1], args[2], args[3]); // new WorkerInterfaceBase(...args);\r\n        //INFO targetWrapper needs for \"apply\" interceptor, it works only for functions as target\r\n        function targetWrapper() {\r\n          return target;\r\n        }\r\n  \r\n        targetWrapper.target = target;\r\n        return new Proxy(targetWrapper, WorkerInterfaceHandlers);\r\n      },\r\n      'get': function(target, name) {\r\n        return target[name];\r\n      },\r\n    });\r\n  \r\n    Object.defineProperties(WorkerInterface, {\r\n      proxyEnabled: {\r\n        value: true\r\n      }\r\n    });\r\n  \r\n    return WorkerInterface;\r\n  })();\r\n  \r\n}else{\r\n  WorkerInterface = (function() {\r\n    function WorkerInterface(importScriptURLs, type) {\r\n      WorkerInterfaceBase.apply(this, arguments);\r\n    }\r\n  \r\n    Object.defineProperties(WorkerInterface, {\r\n      proxyEnabled: {\r\n        value: false\r\n      }\r\n    });\r\n  \r\n    return WorkerInterface;\r\n  })();\r\n  \r\n}\r\nfunction create(importScriptURLs) {\r\n  return new WorkerInterface(importScriptURLs, WorkerInterface.DEDICATED);\r\n}\r\n\r\nWorkerInterface.create = create;\r\nWorkerInterface.isStandalone = isStandalone;\r\nWorkerInterface.generateBlob = generateBlob;\r\nWorkerInterface.fullImportScriptURL = fullImportScriptURL;\r\nWorkerInterface.DEDICATED = WorkerEventDispatcher.WorkerType.DEDICATED_WORKER;\r\n// Shared workers are not supported yet\r\n//WorkerInterface.SHARED = WorkerEventDispatcher.WorkerType.SHARED_WORKER;\r\nWorkerInterface.WorkerEventDispatcher = WorkerEventDispatcher;\r\n\r\n",
    SELF_SRC:"var api = WorkerInterface.self = new WorkerInterface();\r\ntry {\r\n  importScripts(\"{$}\");\r\n} catch (error) {\r\n  console.log(error.name, error.message);\r\n  console.log(error);\r\n}\r\n"};
  eval(Scripts.DEPS_SRC + Scripts.INTERFACE_SRC);
  
  return WorkerInterface;
}));
